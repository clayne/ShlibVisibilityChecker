#!/bin/sh

# The MIT License (MIT)
# 
# Copyright (c) 2018-2019 Yury Gribov
# 
# Use of this source code is governed by The MIT License (MIT)
# that can be found in the LICENSE.txt file.

# TODO: rewrite in Python

set -eu

PATH="$(dirname $0)/../bin:$PATH"

print_help_and_exit() {
  cat <<EOF
Usage: $(basename $0) [OPT]... PKG...
Analyzes difference between public and binary interfaces in Debian packages.

Options:
  -k, --keep      Do not remove temp files after script finishes.
  -o DIR          Store temp files in directory DIR, rather than /tmp
                  (enables --keep).
  -x              Enable shell tracing (for debug).
  -h, --help      Print this help and exit.
  -v, --verbose   Print diagnostic info (can use more than once for more details).
  --permissive    Ignore common dummy symbols (_edata, __bss_start, etc.).
EOF
  exit 1

}

ARGS=$(getopt -o 'o:hkxv' --long 'help,keep,verbose,permissive' -n $(basename $0) -- "$@")
eval set -- "$ARGS"

PERM=
KEEP=
OUT=
V=0
while true; do
  case "$1" in
    -o)
      OUT="$2"
      KEEP=1
      shift 2
      ;;
    -k | --keep)
      KEEP=1
      shift
      ;;
    -x)
      set -x
      shift
      ;;
    --permissive)
      PERM=$1
      shift
      ;;
    -h | --help)
      print_help_and_exit
      ;;
    -v | --verbose)
      V=$((V + 1))
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      error "unknown option: $1"
      ;;
    *)
      error 'internal error'
      ;;
  esac
done

if [ $# -eq 0 ]; then
  print_help_and_exit
fi

get_pkg_attribute() {
  # Parse e.g. "Depends: libc6-dev | libc-dev, libacl1 (= 2.2.52-3), libattr1-dev (>= 1:2.4.46-8)"
  case $2 in
  Binary)
    apt-cache -q showsrc "$1" | grep "^$2:" | tail -n1
    ;;
  *)
    apt-cache -q show "$1" | grep "^$2:"
    ;;
  esac \
    | sed "s/^$2: *//" \
    | sed 's/([^)]*)//g; s/ *|[^,]*//g; s/^ *//; s/ *$//' \
    | sed 's/ *, */\n/g' \
    | sort -u
}

is_bad_pkg() {
  echo "$1" | grep -q '^\(libreoffice\|glibc\)'
}

get_paths() {
#  local CC=clang++-5.0
  local CC=g++
  $CC -E -v -x $1 /dev/null 2>&1 | sed -n '/search starts here/,/End of search list/ { /^ / { s/\(.*\)/-I\1/; p } }' | tr '\n' ' '
}

is_cpp_header() {
  # This is just for diagnostic purposes so can be imprecise
  grep -q '^[         ]*class\>\|\(public\|private\|protected\):\|\<std::\|\<operator\>.*(\|\<template *<' $1
}

get_header_ifaces() {
  local pkg="$1"
  local all_hdrs="$2"
  local wd="$3"

  mkdir -p $wd

  hdrs=$(dpkg -L $pkg | grep '\.\(h\|hpp\|H\)$' | tr '\n' ' ')
  if test $(echo $hdrs | wc -w) = 0; then
    echo >&2 "Failed to locate any headers for package $pkg, skipping..."
    return 0
  fi

  # Collect CFLAGS from pkgconfigs
  local pkgconfig_cflags=$wd/pkgconfigs_cflags.txt
  for pc in $(dpkg -L $pkg | grep '\.pc$' | tr '\n' ' '); do
    local stem="$(basename $pc | sed 's/\.[^.]*$//')"
    PKG_CONFIG_PATH=$(dirname $pc) pkg-config --print-errors --cflags $stem
  done > $pkgconfig_cflags
  sort -uo $pkgconfig_cflags $pkgconfig_cflags

  case $(wc -l < $pkgconfig_cflags) in
  0)
    PKGCONFIG_CFLAGS=
    ;;
  1)
    PKGCONFIG_CFLAGS="$(cat $pkgconfig_cflags)"
    ;;
  *)
    # Try to make sense of several .pc files
    PKGCONFIG_CFLAGS=$(cat $pkgconfig_cflags | tr ' ' '\n' | sort -u | tr '\n' ' ')
    if echo "$PKGCONFIG_CFLAGS" | grep -q '\(^\| \)-D'; then
      echo >&2 'Failed to merge multiple pkgconfig files...'
      PKGCONFIG_CFLAGS=
    fi
    ;;
  esac

  # Extract public interfaces
  CFLAGS="$PKGCONFIG_CFLAGS $(get_paths c)"
  CXXFLAGS="$PKGCONFIG_CFLAGS $(get_paths c++)"
  STDINC="-include stdint.h -include stddef.h -include stdio.h"  # TODO: unistd.h sys/types.h?
  for h in $hdrs; do
    # Try building both C and C++
    if ! read_header_api --only "$all_hdrs" --cflags "$CFLAGS" $h 2>$wd/err_c.log \
        && ! read_header_api --only "$all_hdrs" --cflags "$CXXFLAGS -x c++" $h 2>$wd/err_cpp.log \
        && ! read_header_api --only "$all_hdrs" --cflags "$CFLAGS $STDINC" $h 2>/dev/null \
        && ! read_header_api --only "$all_hdrs" --cflags "$CXXFLAGS $STDINC -x c++" $h 2>/dev/null; then
      # Is this a helper header and so not intended for direct inclusion?
      if ! grep -q '# *include [<"/].*'"$(basename $h)" $all_hdrs; then
        if is_cpp_header "$h"; then
          cat >&2 $wd/err_cpp.log
        else
          cat >&2 $wd/err_c.log
        fi
        echo >&2 "Failed to parse $h..."
        return 1
      fi
    fi
  done
}

analyze_pkg() {
  local pkg="$1"
  local wd="$2"

  mkdir -p $wd

  # Install all binary packages
  local pkgs="$(get_pkg_attribute "$pkg" Binary)"
  local dev_pkgs="$(get_pkg_attribute "$pkg" Binary | grep -- '-dev$')"
  if test $V -gt 0; then
    echo >&2 "$pkg packages: $(echo "$pkgs" | tr '\n' ' ')"
    echo >&2 "$pkg dev packages: $(echo "$dev_pkgs" | tr '\n' ' ')"
  fi
  # Install single package at a time, in case some of them are missing.
  # Use Aptitude to automatically resolve conflicts.
  for p in $pkgs; do
#    apt-get install -qq -y $p
    aptitude install -y -q=2 $p
  done

  # Analyze contents of package
  touch $wd/shlibs.txt $wd/elfs.txt $wd/all_hdrs.txt
  for f in $(dpkg -L $pkgs | grep -v '\.gz$\|\.html\?$'); do
    if file -b $f | grep -q '^ELF.*shared object'; then
      echo $f >> $wd/shlibs.txt
    fi
    if file -b $f | grep -q '^ELF.*\(shared object\|executable\)'; then
      echo $f >> $wd/elfs.txt
    fi
    if echo $f | grep -q '\.\(h\|hpp\|H\)$'; then
      echo $f >> $wd/all_hdrs.txt
    fi
  done

  if test $(wc -l < $wd/all_hdrs.txt) = 0; then
    echo "Headers not found in $pkg, skipping..."
    return 1
  elif test $(wc -l < $wd/shlibs.txt) = 0; then
    echo "Failed to locate any shared libs, skipping $pkg..."
    return 1
  fi

  all_hdrs=$(tr '\n' ' ' < $wd/all_hdrs.txt)
  if test $V -gt 0; then
    echo >&2 "$pkg headers: $all_hdrs"
  fi

  # Collect header interfaces
  for p in $dev_pkgs; do
    if ! get_header_ifaces $p "$all_hdrs" $wd/$p; then
      return 1
    fi
  done > $wd/public_api.txt
  sort -uo $wd/public_api.txt $wd/public_api.txt

  # Collect binary interfaces
  read_binary_api $PERM $(tr '\n' ' ' < $wd/shlibs.txt) > $wd/exported_api.txt

  # Ignore private interfaces used by other modules in same package
  read_binary_api -i --permissive $(tr '\n' ' ' < $wd/elfs.txt) > $wd/private_api.txt
  comm -23 $wd/exported_api.txt $wd/private_api.txt > $wd/exported_api_1.txt

  # TODO: for C++ we may want to ignore vtables, RTTI and C++ default methods
  # (as libclang does not report them).

  # Report extraneous symbols
  comm -13 $wd/public_api.txt $wd/exported_api_1.txt > $wd/exported_only.txt
  if ! test -s $wd/exported_only.txt; then
    echo "All binary symbols are present in public interface of $pkg."
  else
    echo "Binary symbols not in public interface of $pkg:"
    cat $wd/exported_only.txt | sed 's/^/  /'
    local num_bad_binary="$(wc -l < $wd/exported_only.txt)"
    local num_binary="$(wc -l < $wd/exported_api.txt)"
    if test $num_binary -gt 0; then
      rate=$((num_bad_binary * 100 / num_binary))
      rate=" ($rate%)"
    else
      rate=
    fi
    echo "For a total of $num_bad_binary symbols$rate."
  fi

#  # Find missing APIs
#  comm -23 $wd/public_api.txt $wd/exported_api_1.txt > $wd/public_only.txt
#  if ! test -s $wd/public_only.txt; then
#    echo "All APIs are present in shlibs"
#  else
#    echo "APIs not in binary interface:"
#    cat $wd/public_only.txt | sed 's/^/  /'
#  fi

  return 0
}

if test -z "$OUT"; then
  OUT=$(mktemp --suffix=.$(basename $0) -d)
else
  OUT=$(readlink -f $OUT)
fi
mkdir -p $OUT
rm -rf $OUT/*

if test -z "$KEEP"; then
  trap "rm -rf $OUT" EXIT
else
  echo "Files will be stored in $OUT"
fi

total=0
fails=0
failed_packages=
for p in "$@"; do
  TMP=$OUT/tmp
  if ! apt-cache -q showsrc "$p" > $TMP || ! test -s $TMP; then
    echo >&2 "Failed to obtain source package for $p, skipping..."
    continue
  fi

  src="$(grep '^Package:' $TMP | sed 's/^Package: //' | tail -n1)"
  if test -f $OUT/pkgs && grep -q "^$src\$" $OUT/pkgs || is_bad_pkg $src; then
    continue
  fi
  echo $src >> $OUT/pkgs

  total=$((total + 1))
  echo "Processing package $p..."
  if ! analyze_pkg "$src" "$OUT/$src"; then
    echo "Failed to analyze."
    fails=$((fails + 1))
    failed_packages="$failed_packages $src"
  fi
done

echo "$fails packages failed (out of $total):"
echo "$failed_packages" | tr ' ' '\n' | sed 's/^/  /'
