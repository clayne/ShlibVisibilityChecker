#!/bin/sh

# The MIT License (MIT)
# 
# Copyright (c) 2018 Yury Gribov
# 
# Use of this source code is governed by The MIT License (MIT)
# that can be found in the LICENSE.txt file.

# TODO: rewrite in Python

set -eu

read_header_api=$(dirname $0)/../bin/read_header_api

print_help_and_exit() {
  cat <<EOF
Usage: $(basename $0) [OPT]... PKG...
Analyzes difference between public and binary interfaces in Debian packages.

Options:
  -k, --keep      Do not remove temp files after script finishes.
  -o DIR          Store temp files in directory DIR, rather than /tmp
                  (enables --keep).
  -x              Enable shell tracing (for debug).
  -h, --help      Print this help and exit.
  -v, --verbose   Print diagnostic info (can use more than once for more details).
  --permissive    Ignore common dummy symbols (_edata, __bss_start, etc.).
EOF
  exit 1

}

ARGS=$(getopt -o 'o:hkxv' --long 'help,keep,verbose,permissive' -n $(basename $0) -- "$@")
eval set -- "$ARGS"

PERM=
KEEP=
OUT=
V=0
while true; do
  case "$1" in
    -o)
      OUT="$2"
      KEEP=1
      shift 2
      ;;
    -k | --keep)
      KEEP=1
      shift
      ;;
    -x)
      set -x
      shift
      ;;
    --permissive)
      PERM=$1
      shift
      ;;
    -h | --help)
      print_help_and_exit
      ;;
    -v | --verbose)
      V=$((V + 1))
      shift
      ;;
    --)
      shift
      break
      ;;
    -*)
      error "unknown option: $1"
      ;;
    *)
      error 'internal error'
      ;;
  esac
done

if [ $# -eq 0 ]; then
  print_help_and_exit
fi

get_pkg_attribute() {
  # Parse e.g. "Depends: libc6-dev | libc-dev, libacl1 (= 2.2.52-3), libattr1-dev (>= 1:2.4.46-8)"
  case $2 in
  Binary)
    apt-cache -q showsrc "$1" | grep "^$2:" | tail -n1
    ;;
  *)
    apt-cache -q show "$1" | grep "^$2:"
    ;;
  esac \
    | sed "s/^$2: *//" \
    | sed 's/([^)]*)//g; s/ *|[^,]*//g; s/^ *//; s/ *$//' \
    | sed 's/ *, */\n/g' \
    | sort -u
}

is_bad_pkg() {
  echo "$1" | grep -q '^\(libreoffice\|glibc\)'
}

is_cpp_header() {
   grep -q '^[ 	]*class\>\|private:\|public:\|\<operator\>.*(\|\<template *<' $1  # FIXME: ugly...
}

get_header_ifaces() {
  local pkg="$1"
  local all_hdrs="$2"
  local wd="$3"

  mkdir -p $wd

  hdrs=$(dpkg -L $pkg | grep '\.\(h\|hpp\|H\)$' | tr '\n' ' ')
  if test $(echo $hdrs | wc -w) = 0; then
    echo >&2 "Failed to locate any headers for package $pkg, skipping..."
    return 0
  fi

  # Collect CFLAGS from pkgconfigs
  local pkgconfig_cflags=$wd/pkgconfigs_cflags.txt
  for pc in $(dpkg -L $pkg | grep '\.pc$' | tr '\n' ' '); do
    local stem="$(basename $pc | sed 's/\.[^.]*$//')"
    PKG_CONFIG_PATH=$(dirname $pc) pkg-config --print-errors --cflags $stem
  done > $pkgconfig_cflags
  sort -uo $pkgconfig_cflags $pkgconfig_cflags

  case $(wc -l < $pkgconfig_cflags) in
  0)
    PKGCONFIG_CFLAGS=
    ;;
  1)
    PKGCONFIG_CFLAGS="$(cat $pkgconfig_cflags)"
    ;;
  *)
    # Try to make sense of several .pc files
    PKGCONFIG_CFLAGS=$(cat $pkgconfig_cflags | tr ' ' '\n' | sort -u | tr '\n' ' ')
    if echo "$PKGCONFIG_CFLAGS" | grep -q '\(^\| \)-D'; then
      echo >&2 'Failed to merge multiple pkgconfig files...'
      PKGCONFIG_CFLAGS=
    fi
    ;;
  esac

  # Extract public interfaces
  for h in $hdrs; do
    # TODO: determine clang's header path automatically
    CFLAGS="$PKGCONFIG_CFLAGS -I/usr/include -I/usr/include/x86_64-linux-gnu -I/usr/lib/llvm-5.0/lib/clang/5.0.0/include"
    if is_cpp_header $h; then  # TODO: instead try both C and C++
      CFLAGS="$CFLAGS -x c++"
    fi

    # TODO: implement --only
    if ! $read_header_api --only "$all_hdrs" --cflags "$CFLAGS" $h 2> $wd/err.log; then
      if grep -q '# *include [<"/]'"$(basename $h)" $all_hdrs; then
        # This is likely a helper header, not included directly
        continue
      fi

      cat >&2 $wd/err.log
      echo >&2 "Failed to parse $h..."
      return 1
    fi
  done
}

analyze_pkg() {
  local pkg="$1"
  local wd="$2"

  mkdir -p $wd

  # Install all binary packages
  local pkgs="$(get_pkg_attribute "$pkg" Binary)"
  local dev_pkgs="$(get_pkg_attribute "$pkg" Binary | grep -- '-dev$')"
  if test $V -gt 0; then
    echo >&2 "$pkg packages: $(echo "$pkgs" | tr '\n' ' ')"
    echo >&2 "$pkg dev packages: $(echo "$dev_pkgs" | tr '\n' ' ')"
  fi
  for p in $pkgs; do
    apt-get install -qq -y $p  # Install single package at a time, in case some of them are missing
  done

  # Analyze contents of package
  touch $wd/shlibs.txt $wd/elfs.txt $wd/all_hdrs.txt
  for f in $(dpkg -L $pkgs | grep -v '\.gz$\|\.html\?$'); do
    if file -b $f | grep -q '^ELF.*shared object'; then
      echo $f >> $wd/shlibs.txt
    fi
    if file -b $f | grep -q '^ELF.*\(shared object\|executable\)'; then
      echo $f >> $wd/elfs.txt
    fi
    if echo $f | grep -q '\.\(h\|hpp\|H\)$'; then
      echo $f >> $wd/all_hdrs.txt
    fi
  done

  if test $(wc -l < $wd/all_hdrs.txt) = 0; then
    echo "Headers not found in $pkg, skipping..."
    return 1
  elif test $(wc -l < $wd/shlibs.txt) = 0; then
    echo "Failed to locate any shared libs, skipping $pkg..."
    return 1
  fi

  all_hdrs=$(tr '\n' ' ' < $wd/all_hdrs.txt)
  if test $V -gt 0; then
    echo >&2 "$pkg headers: $all_hdrs"
  fi

  # Collect header interfaces
  for p in $dev_pkgs; do
    if ! get_header_ifaces $p "$all_hdrs" $wd/$p; then
      return 1
    fi
  done > $wd/public_api.txt
  sort -uo $wd/public_api.txt $wd/public_api.txt

  # Collect binary interfaces
  $(dirname $0)/read_binary_api $PERM $(tr '\n' ' ' < $wd/shlibs.txt) > $wd/exported_api.txt

  # Ignore private interfaces used by other modules in same package
  $(dirname $0)/read_binary_api -i --permissive $(tr '\n' ' ' < $wd/elfs.txt) > $wd/private_api.txt
  comm -23 $wd/exported_api.txt $wd/private_api.txt > $wd/exported_api_1.txt

  # Find extraneous symbols
  comm -13 $wd/public_api.txt $wd/exported_api_1.txt > $wd/exported_only.txt
  if ! test -s $wd/exported_only.txt; then
    echo "All binary symbols are present in public interface of $pkg."
  else
    echo "Binary symbols not in public interface of $pkg:"
    cat $wd/exported_only.txt | sed 's/^/  /'
    local num_bad_binary="$(wc -l < $wd/exported_only.txt)"
    local num_binary="$(wc -l < $wd/exported_api.txt)"
    if test $num_binary -gt 0; then
      rate=$((num_bad_binary * 100 / num_binary))
      rate=" ($rate%)"
    else
      rate=
    fi
    echo "For a total of $num_bad_binary symbols$rate."
  fi

#  # Find missing APIs
#  comm -23 $wd/public_api.txt $wd/exported_api_1.txt > $wd/public_only.txt
#  if ! test -s $wd/public_only.txt; then
#    echo "All APIs are present in shlibs"
#  else
#    echo "APIs not in binary interface:"
#    cat $wd/public_only.txt | sed 's/^/  /'
#  fi

  return 0
}

if test -z "$OUT"; then
  OUT=$(mktemp --suffix=.$(basename $0) -d)
else
  OUT=$(readlink -f $OUT)
fi
mkdir -p $OUT
rm -rf $OUT/*

if test -z "$KEEP"; then
  trap "rm -rf $OUT" EXIT
else
  echo "Files will be stored in $OUT"
fi

total=0
fails=0
failed_packages=
for p in "$@"; do
  TMP=$OUT/tmp
  if ! apt-cache -q showsrc "$p" > $TMP || ! test -s $TMP; then
    echo >&2 "Failed to obtain source package for $p, skipping..."
    continue
  fi

  src="$(grep '^Package:' $TMP | sed 's/^Package: //' | tail -n1)"
  if test -f $OUT/pkgs && grep -q "^$src\$" $OUT/pkgs || is_bad_pkg $src; then
    continue
  fi
  echo $src >> $OUT/pkgs

  total=$((total + 1))
  echo "Processing package $p..."
  if ! analyze_pkg "$src" "$OUT/$src"; then
    echo "Failed to analyze."
    fails=$((fails + 1))
    failed_packages="$failed_packages $src"
  fi
done

echo "$fails packages failed (out of $total):"
echo "$failed_packages" | tr ' ' '\n' | sed 's/^/  /'
